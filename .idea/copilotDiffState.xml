<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/src/test/java/com/example/weuniteauth/service/AuthServiceTest.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/test/java/com/example/weuniteauth/service/AuthServiceTest.java" />
              <option name="originalContent" value="package com.example.weuniteauth.service;&#10;&#10;import com.example.weuniteauth.domain.User;&#10;import com.example.weuniteauth.dto.AuthDTO;&#10;import com.example.weuniteauth.dto.ResponseDTO;&#10;import com.example.weuniteauth.dto.UserDTO;&#10;import com.example.weuniteauth.dto.auth.*;&#10;import com.example.weuniteauth.dto.user.CreateUserRequestDTO;&#10;import com.example.weuniteauth.exceptions.auth.InvalidTokenException;&#10;import com.example.weuniteauth.exceptions.auth.NotVerifiedEmailException;&#10;import com.example.weuniteauth.exceptions.user.UserNotFoundException;&#10;import com.example.weuniteauth.mapper.AuthMapper;&#10;import com.example.weuniteauth.service.jwt.JwtService;&#10;import com.example.weuniteauth.service.mail.EmailService;&#10;import org.junit.jupiter.api.DisplayName;&#10;import org.junit.jupiter.api.Test;&#10;import org.junit.jupiter.api.extension.ExtendWith;&#10;import org.mockito.InjectMocks;&#10;import org.mockito.Mock;&#10;import org.mockito.junit.jupiter.MockitoExtension;&#10;import org.springframework.security.authentication.BadCredentialsException;&#10;import org.springframework.security.crypto.password.PasswordEncoder;&#10;&#10;import java.time.Instant;&#10;&#10;import static org.junit.jupiter.api.Assertions.*;&#10;import static org.mockito.ArgumentMatchers.anyString;&#10;import static org.mockito.Mockito.*;&#10;&#10;@ExtendWith(MockitoExtension.class)&#10;class AuthServiceTest {&#10;&#10;    @Mock&#10;    private UserService userService;&#10;&#10;    @Mock&#10;    private PasswordEncoder passwordEncoder;&#10;&#10;    @Mock&#10;    private AuthMapper authMapper;&#10;&#10;    @Mock&#10;    private JwtService jwtService;&#10;&#10;    @Mock&#10;    private EmailService emailService;&#10;&#10;    @InjectMocks&#10;    private AuthService authService;&#10;&#10;    @Test&#10;    @DisplayName(&quot;Should login successfully when credentials are valid and email is verified&quot;)&#10;    void loginSuccess() {&#10;        LoginRequestDTO loginRequest = new LoginRequestDTO(&quot;testuser&quot;, &quot;password123&quot;);&#10;&#10;        User mockUser = new User();&#10;        mockUser.setId(1L);&#10;        mockUser.setUsername(&quot;testuser&quot;);&#10;        mockUser.setPassword(&quot;$2a$10$encodedPassword&quot;);&#10;        mockUser.setEmailVerified(true);&#10;        mockUser.setEmail(&quot;test@example.com&quot;);&#10;        mockUser.setName(&quot;Test User&quot;);&#10;        mockUser.setBio(&quot;Test Bio&quot;);&#10;        mockUser.setCreatedAt(Instant.now());&#10;        mockUser.setUpdatedAt(Instant.now());&#10;&#10;        UserDTO expectedUserDTO = new UserDTO(&#10;                mockUser.getId().toString(),&#10;                mockUser.getName(),&#10;                mockUser.getUsername(),&#10;                mockUser.getBio(),&#10;                mockUser.getEmail(),&#10;                mockUser.getProfileImg(),&#10;                mockUser.getCreatedAt(),&#10;                mockUser.getUpdatedAt()&#10;        );&#10;&#10;        AuthDTO authData = new AuthDTO(&#10;                expectedUserDTO,&#10;                &quot;jwt-token&quot;,&#10;                3600L&#10;        );&#10;&#10;        ResponseDTO&lt;AuthDTO&gt; expectedResponse = new ResponseDTO&lt;&gt;(&#10;                &quot;Login realizado com sucesso!&quot;,&#10;                authData&#10;        );&#10;&#10;        when(userService.findUserEntityByUsername(&quot;testuser&quot;)).thenReturn(mockUser);&#10;        when(passwordEncoder.matches(&quot;password123&quot;, &quot;$2a$10$encodedPassword&quot;)).thenReturn(true);&#10;        when(jwtService.generateToken(mockUser)).thenReturn(&quot;jwt-token&quot;);&#10;        when(jwtService.getDefaultTokenExpirationTime()).thenReturn(3600L);&#10;        when(authMapper.toResponseDTO(&quot;Login realizado com sucesso!&quot;, mockUser, &quot;jwt-token&quot;, 3600L))&#10;                .thenReturn(expectedResponse);&#10;&#10;        ResponseDTO&lt;AuthDTO&gt; result = authService.login(loginRequest);&#10;&#10;        assertNotNull(result);&#10;        assertEquals(&quot;Login realizado com sucesso!&quot;, result.message());&#10;        assertNotNull(result.data());&#10;        assertEquals(&quot;testuser&quot;, result.data().user().username());&#10;        assertEquals(&quot;jwt-token&quot;, result.data().jwt());&#10;        assertEquals(3600L, result.data().expiresIn());&#10;&#10;        verify(userService).findUserEntityByUsername(&quot;testuser&quot;);&#10;        verify(passwordEncoder).matches(&quot;password123&quot;, &quot;$2a$10$encodedPassword&quot;);&#10;        verify(jwtService).generateToken(mockUser);&#10;        verify(jwtService).getDefaultTokenExpirationTime();&#10;        verify(authMapper).toResponseDTO(&quot;Login realizado com sucesso!&quot;, mockUser, &quot;jwt-token&quot;, 3600L);&#10;    }&#10;&#10;    @Test&#10;    @DisplayName(&quot;Should throw UserNotFoundException when user does not exist&quot;)&#10;    void loginWithNonExistentUser() {&#10;        LoginRequestDTO loginRequest = new LoginRequestDTO(&quot;nonexistent&quot;, &quot;password123&quot;);&#10;&#10;        when(userService.findUserEntityByUsername(&quot;nonexistent&quot;))&#10;                .thenThrow(new UserNotFoundException());&#10;&#10;        UserNotFoundException exception = assertThrows(UserNotFoundException.class, () -&gt; {&#10;            authService.login(loginRequest);&#10;        });&#10;&#10;        assertNotNull(exception);&#10;        verify(userService).findUserEntityByUsername(&quot;nonexistent&quot;);&#10;        verifyNoInteractions(passwordEncoder, jwtService, authMapper);&#10;    }&#10;&#10;    @Test&#10;    @DisplayName(&quot;Should throw BadCredentialsException when password is incorrect&quot;)&#10;    void loginWithWrongPassword() {&#10;        LoginRequestDTO loginRequest = new LoginRequestDTO(&quot;testuser&quot;, &quot;wrongpassword&quot;);&#10;&#10;        User mockUser = new User();&#10;        mockUser.setUsername(&quot;testuser&quot;);&#10;        mockUser.setPassword(&quot;$2a$10$encodedPassword&quot;);&#10;        mockUser.setEmailVerified(true);&#10;&#10;        when(userService.findUserEntityByUsername(&quot;testuser&quot;)).thenReturn(mockUser);&#10;        when(passwordEncoder.matches(&quot;wrongpassword&quot;, &quot;$2a$10$encodedPassword&quot;)).thenReturn(false);&#10;&#10;        BadCredentialsException exception = assertThrows(BadCredentialsException.class, () -&gt; {&#10;            authService.login(loginRequest);&#10;        });&#10;&#10;        assertEquals(&quot;Usuário ou senha inválidos&quot;, exception.getMessage());&#10;        verify(userService).findUserEntityByUsername(&quot;testuser&quot;);&#10;        verify(passwordEncoder).matches(&quot;wrongpassword&quot;, &quot;$2a$10$encodedPassword&quot;);&#10;        verifyNoInteractions(jwtService, authMapper);&#10;    }&#10;&#10;    @Test&#10;    @DisplayName(&quot;Should throw NotVerifiedEmailException when email is not verified&quot;)&#10;    void loginWithUnverifiedEmail() {&#10;        LoginRequestDTO loginRequest = new LoginRequestDTO(&quot;testuser&quot;, &quot;password123&quot;);&#10;&#10;        User mockUser = new User();&#10;        mockUser.setUsername(&quot;testuser&quot;);&#10;        mockUser.setPassword(&quot;$2a$10$encodedPassword&quot;);&#10;        mockUser.setEmailVerified(false);&#10;&#10;        when(userService.findUserEntityByUsername(&quot;testuser&quot;)).thenReturn(mockUser);&#10;        when(passwordEncoder.matches(&quot;password123&quot;, &quot;$2a$10$encodedPassword&quot;)).thenReturn(true);&#10;&#10;        NotVerifiedEmailException exception = assertThrows(NotVerifiedEmailException.class, () -&gt; {&#10;            authService.login(loginRequest);&#10;        });&#10;&#10;        assertEquals(&quot;Verifique seu email para fazer login&quot;, exception.getMessage());&#10;        verify(userService).findUserEntityByUsername(&quot;testuser&quot;);&#10;        verify(passwordEncoder).matches(&quot;password123&quot;, &quot;$2a$10$encodedPassword&quot;);&#10;        verifyNoInteractions(jwtService, authMapper);&#10;    }&#10;&#10;    @Test&#10;    @DisplayName(&quot;Should signup a user when the data doesn't already exist&quot;)&#10;    void signUpSuccess() {&#10;        CreateUserRequestDTO userRequestDTO = new CreateUserRequestDTO(&#10;                &quot;Luizao&quot;,&#10;                &quot;Luizada&quot;,&#10;                &quot;lgtgusmao@hotmail.com&quot;,&#10;                &quot;123456Cl@&quot;&#10;        );&#10;&#10;        User mockUser = new User();&#10;        mockUser.setUsername(&quot;Luizada&quot;);&#10;        mockUser.setEmail(&quot;lgtgusmao@hotmail.com&quot;);&#10;        mockUser.setVerificationToken(&quot;123456&quot;);&#10;&#10;        ResponseDTO&lt;AuthDTO&gt; expectedResponse = new ResponseDTO&lt;&gt;(&#10;                &quot;Cadastro concluído! Verifique seu email&quot;,&#10;                null&#10;        );&#10;&#10;        when(userService.createUser(userRequestDTO)).thenReturn(mockUser);&#10;        when(authMapper.toResponseDTO(&quot;Cadastro concluído! Verifique seu email&quot;, mockUser))&#10;                .thenReturn(expectedResponse);&#10;&#10;        ResponseDTO&lt;AuthDTO&gt; result = authService.signUp(userRequestDTO);&#10;&#10;        assertNotNull(result);&#10;        assertEquals(&quot;Cadastro concluído! Verifique seu email&quot;, result.message());&#10;&#10;        verify(userService).createUser(userRequestDTO);&#10;        verify(emailService).sendVerificationEmailAsync(&quot;lgtgusmao@hotmail.com&quot;, &quot;123456&quot;);&#10;        verify(authMapper).toResponseDTO(&quot;Cadastro concluído! Verifique seu email&quot;, mockUser);&#10;    }&#10;&#10;    @Test&#10;    @DisplayName(&quot;Should throw exception when userService.createUser fails&quot;)&#10;    void signUpError() {&#10;        CreateUserRequestDTO userRequestDTO = new CreateUserRequestDTO(&#10;                &quot;Luizao&quot;,&#10;                &quot;Luizada&quot;,&#10;                &quot;lgtgusmao@hotmail.com&quot;,&#10;                &quot;123456Cl@&quot;&#10;        );&#10;&#10;        when(userService.createUser(userRequestDTO))&#10;                .thenThrow(new RuntimeException(&quot;Erro ao criar usuário&quot;));&#10;&#10;        RuntimeException exception = assertThrows(RuntimeException.class, () -&gt; {&#10;            authService.signUp(userRequestDTO);&#10;        });&#10;&#10;        assertEquals(&quot;Erro ao criar usuário&quot;, exception.getMessage());&#10;        verify(userService).createUser(userRequestDTO);&#10;        verifyNoInteractions(emailService, authMapper);&#10;    }&#10;&#10;    @Test&#10;    @DisplayName(&quot;Should verify email and return JWT when everything is correct&quot;)&#10;    void verifyEmailSuccess() {&#10;        String email = &quot;test@example.com&quot;;&#10;        String verificationToken = &quot;123456&quot;;&#10;&#10;        VerifyEmailRequestDTO verifyEmailRequestDTO = new VerifyEmailRequestDTO(verificationToken);&#10;&#10;        User mockUser = new User();&#10;        mockUser.setId(1L);&#10;        mockUser.setEmail(email);&#10;        mockUser.setUsername(&quot;testuser&quot;);&#10;        mockUser.setName(&quot;Test User&quot;);&#10;        mockUser.setVerificationToken(verificationToken);&#10;        mockUser.setEmailVerified(false);&#10;&#10;        User verifiedUser = new User();&#10;        verifiedUser.setId(1L);&#10;        verifiedUser.setEmail(email);&#10;        verifiedUser.setUsername(&quot;testuser&quot;);&#10;        verifiedUser.setName(&quot;Test User&quot;);&#10;        verifiedUser.setEmailVerified(true);&#10;&#10;        UserDTO expectedUserDTO = new UserDTO(&#10;                &quot;&quot;,&#10;                mockUser.getId().toString(),&#10;                mockUser.getName(),&#10;                mockUser.getUsername(),&#10;                mockUser.getBio(),&#10;                mockUser.getEmail(),&#10;                mockUser.getCreatedAt(),&#10;                mockUser.getUpdatedAt()&#10;        );&#10;&#10;        AuthDTO authData = new AuthDTO(&#10;                expectedUserDTO,&#10;                &quot;jwt-token&quot;,&#10;                3600L&#10;        );&#10;&#10;        ResponseDTO&lt;AuthDTO&gt; expectedResponse = new ResponseDTO&lt;&gt;(&#10;                &quot;Email verificado com sucesso!&quot;,&#10;                authData&#10;        );&#10;&#10;        when(userService.findUserEntityByEmail(email)).thenReturn(mockUser);&#10;        when(userService.verifyUserEmail(mockUser)).thenReturn(verifiedUser);&#10;        when(jwtService.generateToken(mockUser)).thenReturn(&quot;jwt-token&quot;);&#10;        when(jwtService.getDefaultTokenExpirationTime()).thenReturn(3600L);&#10;        when(authMapper.toResponseDTO(&quot;Email verificado com sucesso!&quot;, mockUser, &quot;jwt-token&quot;, 3600L))&#10;                .thenReturn(expectedResponse);&#10;&#10;        ResponseDTO&lt;AuthDTO&gt; result = authService.verifyEmail(verifyEmailRequestDTO, email);&#10;&#10;        assertNotNull(result);&#10;        assertEquals(&quot;Email verificado com sucesso!&quot;, result.message());&#10;        assertNotNull(result.data());&#10;&#10;        verify(userService).findUserEntityByEmail(email);&#10;        verify(userService).verifyUserEmail(mockUser);&#10;        verify(jwtService).generateToken(mockUser);&#10;        verify(jwtService).getDefaultTokenExpirationTime();&#10;        verify(emailService).sendWelcomeEmail(email, &quot;Test User&quot;);&#10;        verify(authMapper).toResponseDTO(&quot;Email verificado com sucesso!&quot;, mockUser, &quot;jwt-token&quot;, 3600L);&#10;    }&#10;&#10;    @Test&#10;    @DisplayName(&quot;Should throw UserNotFoundException when user is not found by email&quot;)&#10;    void verifyEmailWithUserNotFound() {&#10;        String email = &quot;nonexistent@example.com&quot;;&#10;        String verificationToken = &quot;123456&quot;;&#10;&#10;        VerifyEmailRequestDTO verifyEmailRequestDTO = new VerifyEmailRequestDTO(verificationToken);&#10;&#10;        when(userService.findUserEntityByEmail(email))&#10;                .thenThrow(new UserNotFoundException());&#10;&#10;        UserNotFoundException exception = assertThrows(UserNotFoundException.class, () -&gt; {&#10;            authService.verifyEmail(verifyEmailRequestDTO, email);&#10;        });&#10;&#10;        assertNotNull(exception);&#10;        verify(userService).findUserEntityByEmail(email);&#10;        verifyNoInteractions(jwtService, emailService, authMapper);&#10;    }&#10;&#10;    @Test&#10;    @DisplayName(&quot;Should throw InvalidTokenException when user has no verification token&quot;)&#10;    void verifyEmailWithNullToken() {&#10;        String email = &quot;test@example.com&quot;;&#10;        String requestToken = &quot;123456&quot;;&#10;&#10;        VerifyEmailRequestDTO verifyEmailRequestDTO = new VerifyEmailRequestDTO(requestToken);&#10;&#10;        User mockUser = new User();&#10;        mockUser.setId(1L);&#10;        mockUser.setEmail(email);&#10;        mockUser.setUsername(&quot;testuser&quot;);&#10;        mockUser.setName(&quot;Test User&quot;);&#10;        mockUser.setVerificationToken(null);&#10;        mockUser.setEmailVerified(false);&#10;&#10;        when(userService.findUserEntityByEmail(email)).thenReturn(mockUser);&#10;&#10;        InvalidTokenException exception = assertThrows(InvalidTokenException.class, () -&gt; {&#10;            authService.verifyEmail(verifyEmailRequestDTO, email);&#10;        });&#10;&#10;        assertNotNull(exception);&#10;        verify(userService).findUserEntityByEmail(email);&#10;        verifyNoInteractions(jwtService, emailService, authMapper);&#10;    }&#10;&#10;    @Test&#10;    @DisplayName(&quot;Should throw InvalidTokenException when verification token does not match&quot;)&#10;    void verifyEmailWithInvalidToken() {&#10;        String email = &quot;test@example.com&quot;;&#10;        String correctToken = &quot;123456&quot;;&#10;        String wrongToken = &quot;654321&quot;;&#10;&#10;        VerifyEmailRequestDTO verifyEmailRequestDTO = new VerifyEmailRequestDTO(wrongToken);&#10;&#10;        User mockUser = new User();&#10;        mockUser.setId(1L);&#10;        mockUser.setEmail(email);&#10;        mockUser.setUsername(&quot;testuser&quot;);&#10;        mockUser.setName(&quot;Test User&quot;);&#10;        mockUser.setVerificationToken(correctToken);&#10;        mockUser.setEmailVerified(false);&#10;&#10;        when(userService.findUserEntityByEmail(email)).thenReturn(mockUser);&#10;&#10;        InvalidTokenException exception = assertThrows(InvalidTokenException.class, () -&gt; {&#10;            authService.verifyEmail(verifyEmailRequestDTO, email);&#10;        });&#10;&#10;        assertNotNull(exception);&#10;        verify(userService).findUserEntityByEmail(email);&#10;        verifyNoInteractions(jwtService, emailService, authMapper);&#10;    }&#10;&#10;    @Test&#10;    @DisplayName(&quot;Should send reset password email successfully when user exists and email is verified&quot;)&#10;    void sendResetPasswordSuccess() {&#10;        SendResetPasswordRequestDTO requestDTO = new SendResetPasswordRequestDTO(&quot;test@example.com&quot;);&#10;&#10;        User mockUser = new User();&#10;        mockUser.setId(1L);&#10;        mockUser.setEmail(&quot;test@example.com&quot;);&#10;        mockUser.setUsername(&quot;testuser&quot;);&#10;        mockUser.setName(&quot;Test User&quot;);&#10;        mockUser.setEmailVerified(true);&#10;        mockUser.setVerificationToken(&quot;123456&quot;);&#10;&#10;        ResponseDTO&lt;AuthDTO&gt; expectedResponse = new ResponseDTO&lt;&gt;(&#10;                &quot;Código enviado!&quot;,&#10;                null&#10;        );&#10;&#10;        when(userService.findUserEntityByEmail(&quot;test@example.com&quot;)).thenReturn(mockUser);&#10;        when(userService.generateAndSetToken(mockUser)).thenReturn(mockUser);&#10;        when(authMapper.toResponseDTO(&quot;Código enviado!&quot;)).thenReturn(expectedResponse);&#10;&#10;        ResponseDTO&lt;AuthDTO&gt; result = authService.sendResetPassword(requestDTO);&#10;&#10;        assertNotNull(result);&#10;        assertEquals(&quot;Código enviado!&quot;, result.message());&#10;&#10;        verify(userService).findUserEntityByEmail(&quot;test@example.com&quot;);&#10;        verify(userService).generateAndSetToken(mockUser);&#10;        verify(emailService).sendPasswordResetRequestEmail(&quot;test@example.com&quot;, &quot;123456&quot;);&#10;        verify(authMapper).toResponseDTO(&quot;Código enviado!&quot;);&#10;    }&#10;&#10;    @Test&#10;    @DisplayName(&quot;Should throw UserNotFoundException when user does not exist&quot;)&#10;    void sendResetPasswordWithNonExistentUser() {&#10;        SendResetPasswordRequestDTO requestDTO = new SendResetPasswordRequestDTO(&quot;nonexistent@example.com&quot;);&#10;&#10;        when(userService.findUserEntityByEmail(&quot;nonexistent@example.com&quot;))&#10;                .thenThrow(new UserNotFoundException());&#10;&#10;        UserNotFoundException exception = assertThrows(UserNotFoundException.class, () -&gt; {&#10;            authService.sendResetPassword(requestDTO);&#10;        });&#10;&#10;        assertNotNull(exception);&#10;        verify(userService).findUserEntityByEmail(&quot;nonexistent@example.com&quot;);&#10;        verifyNoInteractions(emailService, authMapper);&#10;        verify(userService, never()).generateAndSetToken(any(User.class));&#10;    }&#10;&#10;    @Test&#10;    @DisplayName(&quot;Should throw NotVerifiedEmailException when user email is not verified&quot;)&#10;    void sendResetPasswordWithUnverifiedEmail() {&#10;        SendResetPasswordRequestDTO requestDTO = new SendResetPasswordRequestDTO(&quot;unverified@example.com&quot;);&#10;&#10;        User mockUser = new User();&#10;        mockUser.setId(1L);&#10;        mockUser.setEmail(&quot;unverified@example.com&quot;);&#10;        mockUser.setUsername(&quot;testuser&quot;);&#10;        mockUser.setName(&quot;Test User&quot;);&#10;        mockUser.setEmailVerified(false);&#10;&#10;        when(userService.findUserEntityByEmail(&quot;unverified@example.com&quot;)).thenReturn(mockUser);&#10;&#10;        NotVerifiedEmailException exception = assertThrows(NotVerifiedEmailException.class, () -&gt; {&#10;            authService.sendResetPassword(requestDTO);&#10;        });&#10;&#10;        assertEquals(&quot;Verifique seu e-mail para redefinir a senha&quot;, exception.getMessage());&#10;        verify(userService).findUserEntityByEmail(&quot;unverified@example.com&quot;);&#10;        verifyNoInteractions(emailService, authMapper);&#10;        verify(userService, never()).generateAndSetToken(any(User.class));&#10;    }&#10;&#10;    @Test&#10;    @DisplayName(&quot;Should verify reset password token successfully when token matches&quot;)&#10;    void verifyResetPasswordTokenSuccess() {&#10;        String email = &quot;test@example.com&quot;;&#10;        String verificationToken = &quot;123456&quot;;&#10;        VerifyResetTokenRequestDTO requestDTO = new VerifyResetTokenRequestDTO(verificationToken);&#10;&#10;        User mockUser = new User();&#10;        mockUser.setId(1L);&#10;        mockUser.setEmail(email);&#10;        mockUser.setUsername(&quot;testuser&quot;);&#10;        mockUser.setName(&quot;Test User&quot;);&#10;        mockUser.setVerificationToken(verificationToken);&#10;&#10;        ResponseDTO&lt;AuthDTO&gt; expectedResponse = new ResponseDTO&lt;&gt;(&#10;                &quot;Código verificado!&quot;,&#10;                null&#10;        );&#10;&#10;        when(userService.findUserEntityByEmail(email)).thenReturn(mockUser);&#10;        when(authMapper.toResponseDTO(&quot;Código verificado!&quot;)).thenReturn(expectedResponse);&#10;&#10;        ResponseDTO&lt;AuthDTO&gt; result = authService.verifyResetPasswordToken(requestDTO, email);&#10;&#10;        assertNotNull(result);&#10;        assertEquals(&quot;Código verificado!&quot;, result.message());&#10;&#10;        verify(userService).findUserEntityByEmail(email);&#10;        verify(authMapper).toResponseDTO(&quot;Código verificado!&quot;);&#10;    }&#10;&#10;    @Test&#10;    @DisplayName(&quot;Should throw UserNotFoundException when user does not exist&quot;)&#10;    void verifyResetPasswordTokenWithNonExistentUser() {&#10;        String email = &quot;nonexistent@example.com&quot;;&#10;        String verificationToken = &quot;123456&quot;;&#10;        VerifyResetTokenRequestDTO requestDTO = new VerifyResetTokenRequestDTO(verificationToken);&#10;&#10;        when(userService.findUserEntityByEmail(email))&#10;                .thenThrow(new UserNotFoundException());&#10;&#10;        UserNotFoundException exception = assertThrows(UserNotFoundException.class, () -&gt; {&#10;            authService.verifyResetPasswordToken(requestDTO, email);&#10;        });&#10;&#10;        assertNotNull(exception);&#10;        verify(userService).findUserEntityByEmail(email);&#10;        verifyNoInteractions(authMapper);&#10;    }&#10;&#10;    @Test&#10;    @DisplayName(&quot;Should throw InvalidTokenException when token does not match&quot;)&#10;    void verifyResetPasswordTokenWithInvalidToken() {&#10;        String email = &quot;test@example.com&quot;;&#10;        String correctToken = &quot;123456&quot;;&#10;        String wrongToken = &quot;654321&quot;;&#10;        VerifyResetTokenRequestDTO requestDTO = new VerifyResetTokenRequestDTO(wrongToken);&#10;&#10;        User mockUser = new User();&#10;        mockUser.setId(1L);&#10;        mockUser.setEmail(email);&#10;        mockUser.setUsername(&quot;testuser&quot;);&#10;        mockUser.setName(&quot;Test User&quot;);&#10;        mockUser.setVerificationToken(correctToken);&#10;&#10;        when(userService.findUserEntityByEmail(email)).thenReturn(mockUser);&#10;&#10;        InvalidTokenException exception = assertThrows(InvalidTokenException.class, () -&gt; {&#10;            authService.verifyResetPasswordToken(requestDTO, email);&#10;        });&#10;&#10;        assertNotNull(exception);&#10;        verify(userService).findUserEntityByEmail(email);&#10;        verifyNoInteractions(authMapper);&#10;    }&#10;&#10;    @Test&#10;    @DisplayName(&quot;Should reset password successfully when verification token is valid&quot;)&#10;    void resetPasswordSuccess() {&#10;        String verificationToken = &quot;123456&quot;;&#10;        String newPassword = &quot;newPassword123@&quot;;&#10;        String encodedPassword = &quot;$2a$10$encodedNewPassword&quot;;&#10;        ResetPasswordRequestDTO requestDTO = new ResetPasswordRequestDTO(newPassword);&#10;&#10;        User mockUser = new User();&#10;        mockUser.setId(1L);&#10;        mockUser.setEmail(&quot;test@example.com&quot;);&#10;        mockUser.setUsername(&quot;testuser&quot;);&#10;        mockUser.setName(&quot;Test User&quot;);&#10;        mockUser.setPassword(&quot;oldEncodedPassword&quot;);&#10;        mockUser.setVerificationToken(verificationToken);&#10;&#10;        ResponseDTO&lt;AuthDTO&gt; expectedResponse = new ResponseDTO&lt;&gt;(&#10;                &quot;Senha redefinida!&quot;,&#10;                null&#10;        );&#10;&#10;        when(userService.findUserByVerificationToken(verificationToken)).thenReturn(mockUser);&#10;        when(passwordEncoder.encode(newPassword)).thenReturn(encodedPassword);&#10;        when(authMapper.toResponseDTO(&quot;Senha redefinida!&quot;)).thenReturn(expectedResponse);&#10;&#10;        ResponseDTO&lt;AuthDTO&gt; result = authService.resetPassword(requestDTO, verificationToken);&#10;&#10;        assertNotNull(result);&#10;        assertEquals(&quot;Senha redefinida!&quot;, result.message());&#10;&#10;        assertEquals(encodedPassword, mockUser.getPassword());&#10;        assertNull(mockUser.getVerificationToken());&#10;        assertNull(mockUser.getVerificationTokenExpires());&#10;&#10;        verify(userService).findUserByVerificationToken(verificationToken);&#10;        verify(passwordEncoder).encode(newPassword);&#10;        verify(emailService).sendPasswordResetSuccessEmail(&quot;test@example.com&quot;);&#10;        verify(authMapper).toResponseDTO(&quot;Senha redefinida!&quot;);&#10;    }&#10;&#10;    @Test&#10;    @DisplayName(&quot;Should throw exception when verification token is not found&quot;)&#10;    void resetPasswordWithInvalidToken() {&#10;        String invalidToken = &quot;invalid123&quot;;&#10;        String newPassword = &quot;newPassword123@&quot;;&#10;        ResetPasswordRequestDTO requestDTO = new ResetPasswordRequestDTO(newPassword);&#10;&#10;        when(userService.findUserByVerificationToken(invalidToken))&#10;                .thenThrow(new UserNotFoundException());&#10;&#10;        UserNotFoundException exception = assertThrows(UserNotFoundException.class, () -&gt; {&#10;            authService.resetPassword(requestDTO, invalidToken);&#10;        });&#10;&#10;        assertNotNull(exception);&#10;        verify(userService).findUserByVerificationToken(invalidToken);&#10;        verifyNoInteractions(passwordEncoder, emailService, authMapper);&#10;    }&#10;}" />
              <option name="updatedContent" value="package com.example.weuniteauth.service;&#10;&#10;import com.example.weuniteauth.domain.User;&#10;import com.example.weuniteauth.dto.AuthDTO;&#10;import com.example.weuniteauth.dto.ResponseDTO;&#10;import com.example.weuniteauth.dto.UserDTO;&#10;import com.example.weuniteauth.dto.auth.*;&#10;import com.example.weuniteauth.dto.user.CreateUserRequestDTO;&#10;import com.example.weuniteauth.exceptions.auth.InvalidTokenException;&#10;import com.example.weuniteauth.exceptions.auth.NotVerifiedEmailException;&#10;import com.example.weuniteauth.exceptions.user.UserNotFoundException;&#10;import com.example.weuniteauth.mapper.AuthMapper;&#10;import com.example.weuniteauth.service.jwt.JwtService;&#10;import com.example.weuniteauth.service.mail.EmailService;&#10;import org.junit.jupiter.api.DisplayName;&#10;import org.junit.jupiter.api.Test;&#10;import org.junit.jupiter.api.extension.ExtendWith;&#10;import org.mockito.InjectMocks;&#10;import org.mockito.Mock;&#10;import org.mockito.junit.jupiter.MockitoExtension;&#10;import org.springframework.security.authentication.BadCredentialsException;&#10;import org.springframework.security.crypto.password.PasswordEncoder;&#10;&#10;import java.time.Instant;&#10;&#10;import static org.junit.jupiter.api.Assertions.*;&#10;import static org.mockito.ArgumentMatchers.anyString;&#10;import static org.mockito.Mockito.*;&#10;&#10;@ExtendWith(MockitoExtension.class)&#10;class AuthServiceTest {&#10;&#10;    @Mock&#10;    private UserService userService;&#10;&#10;    @Mock&#10;    private PasswordEncoder passwordEncoder;&#10;&#10;    @Mock&#10;    private AuthMapper authMapper;&#10;&#10;    @Mock&#10;    private JwtService jwtService;&#10;&#10;    @Mock&#10;    private EmailService emailService;&#10;&#10;    @InjectMocks&#10;    private AuthService authService;&#10;&#10;    @Test&#10;    @DisplayName(&quot;Should login successfully when credentials are valid and email is verified&quot;)&#10;    void loginSuccess() {&#10;        LoginRequestDTO loginRequest = new LoginRequestDTO(&quot;testuser&quot;, &quot;password123&quot;);&#10;&#10;        User mockUser = new User();&#10;        mockUser.setId(1L);&#10;        mockUser.setUsername(&quot;testuser&quot;);&#10;        mockUser.setPassword(&quot;$2a$10$encodedPassword&quot;);&#10;        mockUser.setEmailVerified(true);&#10;        mockUser.setEmail(&quot;test@example.com&quot;);&#10;        mockUser.setName(&quot;Test User&quot;);&#10;        mockUser.setBio(&quot;Test Bio&quot;);&#10;        mockUser.setCreatedAt(Instant.now());&#10;        mockUser.setUpdatedAt(Instant.now());&#10;&#10;        UserDTO expectedUserDTO = new UserDTO(&#10;                mockUser.getId().toString(),&#10;                mockUser.getName(),&#10;                mockUser.getUsername(),&#10;                mockUser.getBio(),&#10;                mockUser.getEmail(),&#10;                mockUser.getProfileImg(),&#10;                mockUser.isPrivate(),&#10;                mockUser.getCreatedAt(),&#10;                mockUser.getUpdatedAt()&#10;        );&#10;&#10;        AuthDTO authData = new AuthDTO(&#10;                expectedUserDTO,&#10;                &quot;jwt-token&quot;,&#10;                3600L&#10;        );&#10;&#10;        ResponseDTO&lt;AuthDTO&gt; expectedResponse = new ResponseDTO&lt;&gt;(&#10;                &quot;Login realizado com sucesso!&quot;,&#10;                authData&#10;        );&#10;&#10;        when(userService.findUserEntityByUsername(&quot;testuser&quot;)).thenReturn(mockUser);&#10;        when(passwordEncoder.matches(&quot;password123&quot;, &quot;$2a$10$encodedPassword&quot;)).thenReturn(true);&#10;        when(jwtService.generateToken(mockUser)).thenReturn(&quot;jwt-token&quot;);&#10;        when(jwtService.getDefaultTokenExpirationTime()).thenReturn(3600L);&#10;        when(authMapper.toResponseDTO(&quot;Login realizado com sucesso!&quot;, mockUser, &quot;jwt-token&quot;, 3600L))&#10;                .thenReturn(expectedResponse);&#10;&#10;        ResponseDTO&lt;AuthDTO&gt; result = authService.login(loginRequest);&#10;&#10;        assertNotNull(result);&#10;        assertEquals(&quot;Login realizado com sucesso!&quot;, result.message());&#10;        assertNotNull(result.data());&#10;        assertEquals(&quot;testuser&quot;, result.data().user().username());&#10;        assertEquals(&quot;jwt-token&quot;, result.data().jwt());&#10;        assertEquals(3600L, result.data().expiresIn());&#10;&#10;        verify(userService).findUserEntityByUsername(&quot;testuser&quot;);&#10;        verify(passwordEncoder).matches(&quot;password123&quot;, &quot;$2a$10$encodedPassword&quot;);&#10;        verify(jwtService).generateToken(mockUser);&#10;        verify(jwtService).getDefaultTokenExpirationTime();&#10;        verify(authMapper).toResponseDTO(&quot;Login realizado com sucesso!&quot;, mockUser, &quot;jwt-token&quot;, 3600L);&#10;    }&#10;&#10;    @Test&#10;    @DisplayName(&quot;Should throw UserNotFoundException when user does not exist&quot;)&#10;    void loginWithNonExistentUser() {&#10;        LoginRequestDTO loginRequest = new LoginRequestDTO(&quot;nonexistent&quot;, &quot;password123&quot;);&#10;&#10;        when(userService.findUserEntityByUsername(&quot;nonexistent&quot;))&#10;                .thenThrow(new UserNotFoundException());&#10;&#10;        UserNotFoundException exception = assertThrows(UserNotFoundException.class, () -&gt; {&#10;            authService.login(loginRequest);&#10;        });&#10;&#10;        assertNotNull(exception);&#10;        verify(userService).findUserEntityByUsername(&quot;nonexistent&quot;);&#10;        verifyNoInteractions(passwordEncoder, jwtService, authMapper);&#10;    }&#10;&#10;    @Test&#10;    @DisplayName(&quot;Should throw BadCredentialsException when password is incorrect&quot;)&#10;    void loginWithWrongPassword() {&#10;        LoginRequestDTO loginRequest = new LoginRequestDTO(&quot;testuser&quot;, &quot;wrongpassword&quot;);&#10;&#10;        User mockUser = new User();&#10;        mockUser.setUsername(&quot;testuser&quot;);&#10;        mockUser.setPassword(&quot;$2a$10$encodedPassword&quot;);&#10;        mockUser.setEmailVerified(true);&#10;&#10;        when(userService.findUserEntityByUsername(&quot;testuser&quot;)).thenReturn(mockUser);&#10;        when(passwordEncoder.matches(&quot;wrongpassword&quot;, &quot;$2a$10$encodedPassword&quot;)).thenReturn(false);&#10;&#10;        BadCredentialsException exception = assertThrows(BadCredentialsException.class, () -&gt; {&#10;            authService.login(loginRequest);&#10;        });&#10;&#10;        assertEquals(&quot;Usuário ou senha inválidos&quot;, exception.getMessage());&#10;        verify(userService).findUserEntityByUsername(&quot;testuser&quot;);&#10;        verify(passwordEncoder).matches(&quot;wrongpassword&quot;, &quot;$2a$10$encodedPassword&quot;);&#10;        verifyNoInteractions(jwtService, authMapper);&#10;    }&#10;&#10;    @Test&#10;    @DisplayName(&quot;Should throw NotVerifiedEmailException when email is not verified&quot;)&#10;    void loginWithUnverifiedEmail() {&#10;        LoginRequestDTO loginRequest = new LoginRequestDTO(&quot;testuser&quot;, &quot;password123&quot;);&#10;&#10;        User mockUser = new User();&#10;        mockUser.setUsername(&quot;testuser&quot;);&#10;        mockUser.setPassword(&quot;$2a$10$encodedPassword&quot;);&#10;        mockUser.setEmailVerified(false);&#10;&#10;        when(userService.findUserEntityByUsername(&quot;testuser&quot;)).thenReturn(mockUser);&#10;        when(passwordEncoder.matches(&quot;password123&quot;, &quot;$2a$10$encodedPassword&quot;)).thenReturn(true);&#10;&#10;        NotVerifiedEmailException exception = assertThrows(NotVerifiedEmailException.class, () -&gt; {&#10;            authService.login(loginRequest);&#10;        });&#10;&#10;        assertEquals(&quot;Verifique seu email para fazer login&quot;, exception.getMessage());&#10;        verify(userService).findUserEntityByUsername(&quot;testuser&quot;);&#10;        verify(passwordEncoder).matches(&quot;password123&quot;, &quot;$2a$10$encodedPassword&quot;);&#10;        verifyNoInteractions(jwtService, authMapper);&#10;    }&#10;&#10;    @Test&#10;    @DisplayName(&quot;Should signup a user when the data doesn't already exist&quot;)&#10;    void signUpSuccess() {&#10;        CreateUserRequestDTO userRequestDTO = new CreateUserRequestDTO(&#10;                &quot;Luizao&quot;,&#10;                &quot;Luizada&quot;,&#10;                &quot;lgtgusmao@hotmail.com&quot;,&#10;                &quot;123456Cl@&quot;&#10;        );&#10;&#10;        User mockUser = new User();&#10;        mockUser.setUsername(&quot;Luizada&quot;);&#10;        mockUser.setEmail(&quot;lgtgusmao@hotmail.com&quot;);&#10;        mockUser.setVerificationToken(&quot;123456&quot;);&#10;&#10;        ResponseDTO&lt;AuthDTO&gt; expectedResponse = new ResponseDTO&lt;&gt;(&#10;                &quot;Cadastro concluído! Verifique seu email&quot;,&#10;                null&#10;        );&#10;&#10;        when(userService.createUser(userRequestDTO)).thenReturn(mockUser);&#10;        when(authMapper.toResponseDTO(&quot;Cadastro concluído! Verifique seu email&quot;, mockUser))&#10;                .thenReturn(expectedResponse);&#10;&#10;        ResponseDTO&lt;AuthDTO&gt; result = authService.signUp(userRequestDTO);&#10;&#10;        assertNotNull(result);&#10;        assertEquals(&quot;Cadastro concluído! Verifique seu email&quot;, result.message());&#10;&#10;        verify(userService).createUser(userRequestDTO);&#10;        verify(emailService).sendVerificationEmailAsync(&quot;lgtgusmao@hotmail.com&quot;, &quot;123456&quot;);&#10;        verify(authMapper).toResponseDTO(&quot;Cadastro concluído! Verifique seu email&quot;, mockUser);&#10;    }&#10;&#10;    @Test&#10;    @DisplayName(&quot;Should throw exception when userService.createUser fails&quot;)&#10;    void signUpError() {&#10;        CreateUserRequestDTO userRequestDTO = new CreateUserRequestDTO(&#10;                &quot;Luizao&quot;,&#10;                &quot;Luizada&quot;,&#10;                &quot;lgtgusmao@hotmail.com&quot;,&#10;                &quot;123456Cl@&quot;&#10;        );&#10;&#10;        when(userService.createUser(userRequestDTO))&#10;                .thenThrow(new RuntimeException(&quot;Erro ao criar usuário&quot;));&#10;&#10;        RuntimeException exception = assertThrows(RuntimeException.class, () -&gt; {&#10;            authService.signUp(userRequestDTO);&#10;        });&#10;&#10;        assertEquals(&quot;Erro ao criar usuário&quot;, exception.getMessage());&#10;        verify(userService).createUser(userRequestDTO);&#10;        verifyNoInteractions(emailService, authMapper);&#10;    }&#10;&#10;    @Test&#10;    @DisplayName(&quot;Should verify email and return JWT when everything is correct&quot;)&#10;    void verifyEmailSuccess() {&#10;        String email = &quot;test@example.com&quot;;&#10;        String verificationToken = &quot;123456&quot;;&#10;&#10;        VerifyEmailRequestDTO verifyEmailRequestDTO = new VerifyEmailRequestDTO(verificationToken);&#10;&#10;        User mockUser = new User();&#10;        mockUser.setId(1L);&#10;        mockUser.setEmail(email);&#10;        mockUser.setUsername(&quot;testuser&quot;);&#10;        mockUser.setName(&quot;Test User&quot;);&#10;        mockUser.setVerificationToken(verificationToken);&#10;        mockUser.setEmailVerified(false);&#10;&#10;        User verifiedUser = new User();&#10;        verifiedUser.setId(1L);&#10;        verifiedUser.setEmail(email);&#10;        verifiedUser.setUsername(&quot;testuser&quot;);&#10;        verifiedUser.setName(&quot;Test User&quot;);&#10;        verifiedUser.setEmailVerified(true);&#10;&#10;        UserDTO expectedUserDTO = new UserDTO(&#10;                mockUser.getId().toString(),&#10;                mockUser.getName(),&#10;                mockUser.getUsername(),&#10;                mockUser.getBio(),&#10;                mockUser.getEmail(),&#10;                mockUser.getProfileImg(),&#10;                mockUser.isPrivate(),&#10;                mockUser.getCreatedAt(),&#10;                mockUser.getUpdatedAt()&#10;        );&#10;&#10;        AuthDTO authData = new AuthDTO(&#10;                expectedUserDTO,&#10;                &quot;jwt-token&quot;,&#10;                3600L&#10;        );&#10;&#10;        ResponseDTO&lt;AuthDTO&gt; expectedResponse = new ResponseDTO&lt;&gt;(&#10;                &quot;Email verificado com sucesso!&quot;,&#10;                authData&#10;        );&#10;&#10;        when(userService.findUserEntityByEmail(email)).thenReturn(mockUser);&#10;        when(userService.verifyUserEmail(mockUser)).thenReturn(verifiedUser);&#10;        when(jwtService.generateToken(mockUser)).thenReturn(&quot;jwt-token&quot;);&#10;        when(jwtService.getDefaultTokenExpirationTime()).thenReturn(3600L);&#10;        when(authMapper.toResponseDTO(&quot;Email verificado com sucesso!&quot;, mockUser, &quot;jwt-token&quot;, 3600L))&#10;                .thenReturn(expectedResponse);&#10;&#10;        ResponseDTO&lt;AuthDTO&gt; result = authService.verifyEmail(verifyEmailRequestDTO, email);&#10;&#10;        assertNotNull(result);&#10;        assertEquals(&quot;Email verificado com sucesso!&quot;, result.message());&#10;        assertNotNull(result.data());&#10;&#10;        verify(userService).findUserEntityByEmail(email);&#10;        verify(userService).verifyUserEmail(mockUser);&#10;        verify(jwtService).generateToken(mockUser);&#10;        verify(jwtService).getDefaultTokenExpirationTime();&#10;        verify(emailService).sendWelcomeEmail(email, &quot;Test User&quot;);&#10;        verify(authMapper).toResponseDTO(&quot;Email verificado com sucesso!&quot;, mockUser, &quot;jwt-token&quot;, 3600L);&#10;    }&#10;&#10;    @Test&#10;    @DisplayName(&quot;Should throw UserNotFoundException when user is not found by email&quot;)&#10;    void verifyEmailWithUserNotFound() {&#10;        String email = &quot;nonexistent@example.com&quot;;&#10;        String verificationToken = &quot;123456&quot;;&#10;&#10;        VerifyEmailRequestDTO verifyEmailRequestDTO = new VerifyEmailRequestDTO(verificationToken);&#10;&#10;        when(userService.findUserEntityByEmail(email))&#10;                .thenThrow(new UserNotFoundException());&#10;&#10;        UserNotFoundException exception = assertThrows(UserNotFoundException.class, () -&gt; {&#10;            authService.verifyEmail(verifyEmailRequestDTO, email);&#10;        });&#10;&#10;        assertNotNull(exception);&#10;        verify(userService).findUserEntityByEmail(email);&#10;        verifyNoInteractions(jwtService, emailService, authMapper);&#10;    }&#10;&#10;    @Test&#10;    @DisplayName(&quot;Should throw InvalidTokenException when user has no verification token&quot;)&#10;    void verifyEmailWithNullToken() {&#10;        String email = &quot;test@example.com&quot;;&#10;        String requestToken = &quot;123456&quot;;&#10;&#10;        VerifyEmailRequestDTO verifyEmailRequestDTO = new VerifyEmailRequestDTO(requestToken);&#10;&#10;        User mockUser = new User();&#10;        mockUser.setId(1L);&#10;        mockUser.setEmail(email);&#10;        mockUser.setUsername(&quot;testuser&quot;);&#10;        mockUser.setName(&quot;Test User&quot;);&#10;        mockUser.setVerificationToken(null);&#10;        mockUser.setEmailVerified(false);&#10;&#10;        when(userService.findUserEntityByEmail(email)).thenReturn(mockUser);&#10;&#10;        InvalidTokenException exception = assertThrows(InvalidTokenException.class, () -&gt; {&#10;            authService.verifyEmail(verifyEmailRequestDTO, email);&#10;        });&#10;&#10;        assertNotNull(exception);&#10;        verify(userService).findUserEntityByEmail(email);&#10;        verifyNoInteractions(jwtService, emailService, authMapper);&#10;    }&#10;&#10;    @Test&#10;    @DisplayName(&quot;Should throw InvalidTokenException when verification token does not match&quot;)&#10;    void verifyEmailWithInvalidToken() {&#10;        String email = &quot;test@example.com&quot;;&#10;        String correctToken = &quot;123456&quot;;&#10;        String wrongToken = &quot;654321&quot;;&#10;&#10;        VerifyEmailRequestDTO verifyEmailRequestDTO = new VerifyEmailRequestDTO(wrongToken);&#10;&#10;        User mockUser = new User();&#10;        mockUser.setId(1L);&#10;        mockUser.setEmail(email);&#10;        mockUser.setUsername(&quot;testuser&quot;);&#10;        mockUser.setName(&quot;Test User&quot;);&#10;        mockUser.setVerificationToken(correctToken);&#10;        mockUser.setEmailVerified(false);&#10;&#10;        when(userService.findUserEntityByEmail(email)).thenReturn(mockUser);&#10;&#10;        InvalidTokenException exception = assertThrows(InvalidTokenException.class, () -&gt; {&#10;            authService.verifyEmail(verifyEmailRequestDTO, email);&#10;        });&#10;&#10;        assertNotNull(exception);&#10;        verify(userService).findUserEntityByEmail(email);&#10;        verifyNoInteractions(jwtService, emailService, authMapper);&#10;    }&#10;&#10;    @Test&#10;    @DisplayName(&quot;Should send reset password email successfully when user exists and email is verified&quot;)&#10;    void sendResetPasswordSuccess() {&#10;        SendResetPasswordRequestDTO requestDTO = new SendResetPasswordRequestDTO(&quot;test@example.com&quot;);&#10;&#10;        User mockUser = new User();&#10;        mockUser.setId(1L);&#10;        mockUser.setEmail(&quot;test@example.com&quot;);&#10;        mockUser.setUsername(&quot;testuser&quot;);&#10;        mockUser.setName(&quot;Test User&quot;);&#10;        mockUser.setEmailVerified(true);&#10;        mockUser.setVerificationToken(&quot;123456&quot;);&#10;&#10;        ResponseDTO&lt;AuthDTO&gt; expectedResponse = new ResponseDTO&lt;&gt;(&#10;                &quot;Código enviado!&quot;,&#10;                null&#10;        );&#10;&#10;        when(userService.findUserEntityByEmail(&quot;test@example.com&quot;)).thenReturn(mockUser);&#10;        when(userService.generateAndSetToken(mockUser)).thenReturn(mockUser);&#10;        when(authMapper.toResponseDTO(&quot;Código enviado!&quot;)).thenReturn(expectedResponse);&#10;&#10;        ResponseDTO&lt;AuthDTO&gt; result = authService.sendResetPassword(requestDTO);&#10;&#10;        assertNotNull(result);&#10;        assertEquals(&quot;Código enviado!&quot;, result.message());&#10;&#10;        verify(userService).findUserEntityByEmail(&quot;test@example.com&quot;);&#10;        verify(userService).generateAndSetToken(mockUser);&#10;        verify(emailService).sendPasswordResetRequestEmail(&quot;test@example.com&quot;, &quot;123456&quot;);&#10;        verify(authMapper).toResponseDTO(&quot;Código enviado!&quot;);&#10;    }&#10;&#10;    @Test&#10;    @DisplayName(&quot;Should throw UserNotFoundException when user does not exist&quot;)&#10;    void sendResetPasswordWithNonExistentUser() {&#10;        SendResetPasswordRequestDTO requestDTO = new SendResetPasswordRequestDTO(&quot;nonexistent@example.com&quot;);&#10;&#10;        when(userService.findUserEntityByEmail(&quot;nonexistent@example.com&quot;))&#10;                .thenThrow(new UserNotFoundException());&#10;&#10;        UserNotFoundException exception = assertThrows(UserNotFoundException.class, () -&gt; {&#10;            authService.sendResetPassword(requestDTO);&#10;        });&#10;&#10;        assertNotNull(exception);&#10;        verify(userService).findUserEntityByEmail(&quot;nonexistent@example.com&quot;);&#10;        verifyNoInteractions(emailService, authMapper);&#10;        verify(userService, never()).generateAndSetToken(any(User.class));&#10;    }&#10;&#10;    @Test&#10;    @DisplayName(&quot;Should throw NotVerifiedEmailException when user email is not verified&quot;)&#10;    void sendResetPasswordWithUnverifiedEmail() {&#10;        SendResetPasswordRequestDTO requestDTO = new SendResetPasswordRequestDTO(&quot;unverified@example.com&quot;);&#10;&#10;        User mockUser = new User();&#10;        mockUser.setId(1L);&#10;        mockUser.setEmail(&quot;unverified@example.com&quot;);&#10;        mockUser.setUsername(&quot;testuser&quot;);&#10;        mockUser.setName(&quot;Test User&quot;);&#10;        mockUser.setEmailVerified(false);&#10;&#10;        when(userService.findUserEntityByEmail(&quot;unverified@example.com&quot;)).thenReturn(mockUser);&#10;&#10;        NotVerifiedEmailException exception = assertThrows(NotVerifiedEmailException.class, () -&gt; {&#10;            authService.sendResetPassword(requestDTO);&#10;        });&#10;&#10;        assertEquals(&quot;Verifique seu e-mail para redefinir a senha&quot;, exception.getMessage());&#10;        verify(userService).findUserEntityByEmail(&quot;unverified@example.com&quot;);&#10;        verifyNoInteractions(emailService, authMapper);&#10;        verify(userService, never()).generateAndSetToken(any(User.class));&#10;    }&#10;&#10;    @Test&#10;    @DisplayName(&quot;Should verify reset password token successfully when token matches&quot;)&#10;    void verifyResetPasswordTokenSuccess() {&#10;        String email = &quot;test@example.com&quot;;&#10;        String verificationToken = &quot;123456&quot;;&#10;        VerifyResetTokenRequestDTO requestDTO = new VerifyResetTokenRequestDTO(verificationToken);&#10;&#10;        User mockUser = new User();&#10;        mockUser.setId(1L);&#10;        mockUser.setEmail(email);&#10;        mockUser.setUsername(&quot;testuser&quot;);&#10;        mockUser.setName(&quot;Test User&quot;);&#10;        mockUser.setVerificationToken(verificationToken);&#10;&#10;        ResponseDTO&lt;AuthDTO&gt; expectedResponse = new ResponseDTO&lt;&gt;(&#10;                &quot;Código verificado!&quot;,&#10;                null&#10;        );&#10;&#10;        when(userService.findUserEntityByEmail(email)).thenReturn(mockUser);&#10;        when(authMapper.toResponseDTO(&quot;Código verificado!&quot;)).thenReturn(expectedResponse);&#10;&#10;        ResponseDTO&lt;AuthDTO&gt; result = authService.verifyResetPasswordToken(requestDTO, email);&#10;&#10;        assertNotNull(result);&#10;        assertEquals(&quot;Código verificado!&quot;, result.message());&#10;&#10;        verify(userService).findUserEntityByEmail(email);&#10;        verify(authMapper).toResponseDTO(&quot;Código verificado!&quot;);&#10;    }&#10;&#10;    @Test&#10;    @DisplayName(&quot;Should throw UserNotFoundException when user does not exist&quot;)&#10;    void verifyResetPasswordTokenWithNonExistentUser() {&#10;        String email = &quot;nonexistent@example.com&quot;;&#10;        String verificationToken = &quot;123456&quot;;&#10;        VerifyResetTokenRequestDTO requestDTO = new VerifyResetTokenRequestDTO(verificationToken);&#10;&#10;        when(userService.findUserEntityByEmail(email))&#10;                .thenThrow(new UserNotFoundException());&#10;&#10;        UserNotFoundException exception = assertThrows(UserNotFoundException.class, () -&gt; {&#10;            authService.verifyResetPasswordToken(requestDTO, email);&#10;        });&#10;&#10;        assertNotNull(exception);&#10;        verify(userService).findUserEntityByEmail(email);&#10;        verifyNoInteractions(authMapper);&#10;    }&#10;&#10;    @Test&#10;    @DisplayName(&quot;Should throw InvalidTokenException when token does not match&quot;)&#10;    void verifyResetPasswordTokenWithInvalidToken() {&#10;        String email = &quot;test@example.com&quot;;&#10;        String correctToken = &quot;123456&quot;;&#10;        String wrongToken = &quot;654321&quot;;&#10;        VerifyResetTokenRequestDTO requestDTO = new VerifyResetTokenRequestDTO(wrongToken);&#10;&#10;        User mockUser = new User();&#10;        mockUser.setId(1L);&#10;        mockUser.setEmail(email);&#10;        mockUser.setUsername(&quot;testuser&quot;);&#10;        mockUser.setName(&quot;Test User&quot;);&#10;        mockUser.setVerificationToken(correctToken);&#10;&#10;        when(userService.findUserEntityByEmail(email)).thenReturn(mockUser);&#10;&#10;        InvalidTokenException exception = assertThrows(InvalidTokenException.class, () -&gt; {&#10;            authService.verifyResetPasswordToken(requestDTO, email);&#10;        });&#10;&#10;        assertNotNull(exception);&#10;        verify(userService).findUserEntityByEmail(email);&#10;        verifyNoInteractions(authMapper);&#10;    }&#10;&#10;    @Test&#10;    @DisplayName(&quot;Should reset password successfully when verification token is valid&quot;)&#10;    void resetPasswordSuccess() {&#10;        String verificationToken = &quot;123456&quot;;&#10;        String newPassword = &quot;newPassword123@&quot;;&#10;        String encodedPassword = &quot;$2a$10$encodedNewPassword&quot;;&#10;        ResetPasswordRequestDTO requestDTO = new ResetPasswordRequestDTO(newPassword);&#10;&#10;        User mockUser = new User();&#10;        mockUser.setId(1L);&#10;        mockUser.setEmail(&quot;test@example.com&quot;);&#10;        mockUser.setUsername(&quot;testuser&quot;);&#10;        mockUser.setName(&quot;Test User&quot;);&#10;        mockUser.setPassword(&quot;oldEncodedPassword&quot;);&#10;        mockUser.setVerificationToken(verificationToken);&#10;&#10;        ResponseDTO&lt;AuthDTO&gt; expectedResponse = new ResponseDTO&lt;&gt;(&#10;                &quot;Senha redefinida!&quot;,&#10;                null&#10;        );&#10;&#10;        when(userService.findUserByVerificationToken(verificationToken)).thenReturn(mockUser);&#10;        when(passwordEncoder.encode(newPassword)).thenReturn(encodedPassword);&#10;        when(authMapper.toResponseDTO(&quot;Senha redefinida!&quot;)).thenReturn(expectedResponse);&#10;&#10;        ResponseDTO&lt;AuthDTO&gt; result = authService.resetPassword(requestDTO, verificationToken);&#10;&#10;        assertNotNull(result);&#10;        assertEquals(&quot;Senha redefinida!&quot;, result.message());&#10;&#10;        assertEquals(encodedPassword, mockUser.getPassword());&#10;        assertNull(mockUser.getVerificationToken());&#10;        assertNull(mockUser.getVerificationTokenExpires());&#10;&#10;        verify(userService).findUserByVerificationToken(verificationToken);&#10;        verify(passwordEncoder).encode(newPassword);&#10;        verify(emailService).sendPasswordResetSuccessEmail(&quot;test@example.com&quot;);&#10;        verify(authMapper).toResponseDTO(&quot;Senha redefinida!&quot;);&#10;    }&#10;&#10;    @Test&#10;    @DisplayName(&quot;Should throw exception when verification token is not found&quot;)&#10;    void resetPasswordWithInvalidToken() {&#10;        String invalidToken = &quot;invalid123&quot;;&#10;        String newPassword = &quot;newPassword123@&quot;;&#10;        ResetPasswordRequestDTO requestDTO = new ResetPasswordRequestDTO(newPassword);&#10;&#10;        when(userService.findUserByVerificationToken(invalidToken))&#10;                .thenThrow(new UserNotFoundException());&#10;&#10;        UserNotFoundException exception = assertThrows(UserNotFoundException.class, () -&gt; {&#10;            authService.resetPassword(requestDTO, invalidToken);&#10;        });&#10;&#10;        assertNotNull(exception);&#10;        verify(userService).findUserByVerificationToken(invalidToken);&#10;        verifyNoInteractions(passwordEncoder, emailService, authMapper);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/test/java/com/example/weuniteauth/service/UserServiceVisibilityTest.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/test/java/com/example/weuniteauth/service/UserServiceVisibilityTest.java" />
              <option name="updatedContent" value="package com.example.weuniteauth.service;&#10;&#10;import com.example.weuniteauth.domain.User;&#10;import com.example.weuniteauth.dto.ResponseDTO;&#10;import com.example.weuniteauth.dto.UserDTO;&#10;import com.example.weuniteauth.exceptions.user.UserNotFoundException;&#10;import com.example.weuniteauth.mapper.UserMapper;&#10;import com.example.weuniteauth.repository.UserRepository;&#10;import org.junit.jupiter.api.DisplayName;&#10;import org.junit.jupiter.api.Test;&#10;import org.junit.jupiter.api.extension.ExtendWith;&#10;import org.mockito.InjectMocks;&#10;import org.mockito.Mock;&#10;import org.mockito.junit.jupiter.MockitoExtension;&#10;&#10;import java.time.Instant;&#10;import java.util.Optional;&#10;&#10;import static org.junit.jupiter.api.Assertions.*;&#10;import static org.mockito.ArgumentMatchers.any;&#10;import static org.mockito.Mockito.*;&#10;&#10;@ExtendWith(MockitoExtension.class)&#10;class UserServiceVisibilityTest {&#10;&#10;    @Mock&#10;    private UserRepository userRepository;&#10;&#10;    @Mock&#10;    private UserMapper userMapper;&#10;&#10;    @InjectMocks&#10;    private UserService userService;&#10;&#10;    @Test&#10;    @DisplayName(&quot;Should update user visibility to private successfully&quot;)&#10;    void updateUserVisibilityToPrivateSuccess() {&#10;        String username = &quot;testuser&quot;;&#10;        boolean isPrivate = true;&#10;&#10;        User mockUser = new User();&#10;        mockUser.setId(1L);&#10;        mockUser.setUsername(username);&#10;        mockUser.setName(&quot;Test User&quot;);&#10;        mockUser.setEmail(&quot;test@example.com&quot;);&#10;        mockUser.setPrivate(false);&#10;        mockUser.setCreatedAt(Instant.now());&#10;        mockUser.setUpdatedAt(Instant.now());&#10;&#10;        UserDTO expectedUserDTO = new UserDTO(&#10;                mockUser.getId().toString(),&#10;                mockUser.getName(),&#10;                mockUser.getUsername(),&#10;                mockUser.getBio(),&#10;                mockUser.getEmail(),&#10;                mockUser.getProfileImg(),&#10;                true,&#10;                mockUser.getCreatedAt(),&#10;                mockUser.getUpdatedAt()&#10;        );&#10;&#10;        ResponseDTO&lt;UserDTO&gt; expectedResponse = new ResponseDTO&lt;&gt;(&#10;                &quot;Visibilidade atualizada com sucesso!&quot;,&#10;                expectedUserDTO&#10;        );&#10;&#10;        when(userRepository.findByUsername(username)).thenReturn(Optional.of(mockUser));&#10;        when(userRepository.save(any(User.class))).thenReturn(mockUser);&#10;        when(userMapper.toResponseDTO(&quot;Visibilidade atualizada com sucesso!&quot;, mockUser))&#10;                .thenReturn(expectedResponse);&#10;&#10;        ResponseDTO&lt;UserDTO&gt; result = userService.updateUserVisibility(username, isPrivate);&#10;&#10;        assertNotNull(result);&#10;        assertEquals(&quot;Visibilidade atualizada com sucesso!&quot;, result.message());&#10;        assertTrue(result.data().isPrivate());&#10;&#10;        verify(userRepository).findByUsername(username);&#10;        verify(userRepository).save(mockUser);&#10;        verify(userMapper).toResponseDTO(&quot;Visibilidade atualizada com sucesso!&quot;, mockUser);&#10;&#10;        assertTrue(mockUser.isPrivate());&#10;    }&#10;&#10;    @Test&#10;    @DisplayName(&quot;Should update user visibility to public successfully&quot;)&#10;    void updateUserVisibilityToPublicSuccess() {&#10;        String username = &quot;testuser&quot;;&#10;        boolean isPrivate = false;&#10;&#10;        User mockUser = new User();&#10;        mockUser.setId(1L);&#10;        mockUser.setUsername(username);&#10;        mockUser.setName(&quot;Test User&quot;);&#10;        mockUser.setEmail(&quot;test@example.com&quot;);&#10;        mockUser.setPrivate(true);&#10;        mockUser.setCreatedAt(Instant.now());&#10;        mockUser.setUpdatedAt(Instant.now());&#10;&#10;        UserDTO expectedUserDTO = new UserDTO(&#10;                mockUser.getId().toString(),&#10;                mockUser.getName(),&#10;                mockUser.getUsername(),&#10;                mockUser.getBio(),&#10;                mockUser.getEmail(),&#10;                mockUser.getProfileImg(),&#10;                false,&#10;                mockUser.getCreatedAt(),&#10;                mockUser.getUpdatedAt()&#10;        );&#10;&#10;        ResponseDTO&lt;UserDTO&gt; expectedResponse = new ResponseDTO&lt;&gt;(&#10;                &quot;Visibilidade atualizada com sucesso!&quot;,&#10;                expectedUserDTO&#10;        );&#10;&#10;        when(userRepository.findByUsername(username)).thenReturn(Optional.of(mockUser));&#10;        when(userRepository.save(any(User.class))).thenReturn(mockUser);&#10;        when(userMapper.toResponseDTO(&quot;Visibilidade atualizada com sucesso!&quot;, mockUser))&#10;                .thenReturn(expectedResponse);&#10;&#10;        ResponseDTO&lt;UserDTO&gt; result = userService.updateUserVisibility(username, isPrivate);&#10;&#10;        assertNotNull(result);&#10;        assertEquals(&quot;Visibilidade atualizada com sucesso!&quot;, result.message());&#10;        assertFalse(result.data().isPrivate());&#10;&#10;        verify(userRepository).findByUsername(username);&#10;        verify(userRepository).save(mockUser);&#10;        verify(userMapper).toResponseDTO(&quot;Visibilidade atualizada com sucesso!&quot;, mockUser);&#10;&#10;        assertFalse(mockUser.isPrivate());&#10;    }&#10;&#10;    @Test&#10;    @DisplayName(&quot;Should throw UserNotFoundException when user does not exist&quot;)&#10;    void updateUserVisibilityWithNonExistentUser() {&#10;        String username = &quot;nonexistent&quot;;&#10;        boolean isPrivate = true;&#10;&#10;        when(userRepository.findByUsername(username)).thenReturn(Optional.empty());&#10;&#10;        UserNotFoundException exception = assertThrows(UserNotFoundException.class, () -&gt; {&#10;            userService.updateUserVisibility(username, isPrivate);&#10;        });&#10;&#10;        assertNotNull(exception);&#10;        verify(userRepository).findByUsername(username);&#10;        verify(userRepository, never()).save(any(User.class));&#10;        verifyNoInteractions(userMapper);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>